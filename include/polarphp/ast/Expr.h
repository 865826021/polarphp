//===--- Expr.h - Swift Language Expression ASTs ----------------*- C++ -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2018 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// This source file is part of the polarphp.org open source project
//
// Copyright (c) 2017 - 2019 polarphp software foundation
// Copyright (c) 2017 - 2019 zzu_softboy <zzu_softboy@163.com>
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://polarphp.org/LICENSE.txt for license information
// See https://polarphp.org/CONTRIBUTORS.txt for the list of polarphp project authors
//
// Created by polarboy on 2019/04/26.
//===----------------------------------------------------------------------===//
//
// This file defines the Expr class and subclasses.
//
//===----------------------------------------------------------------------===//

#ifndef POLARPHP_AST_EXPR_H
#define POLARPHP_AST_EXPR_H

#include "polarphp/ast/CaptureInfo.h"
//#include "polarphp/ast/ConcreteDeclRef.h"
#include "polarphp/ast/DeclNameLoc.h"
//#include "polarphp/ast/FunctionRefKind.h"
#include "polarphp/ast/TypeAlignments.h"
#include "polarphp/ast/TypeLoc.h"
#include "polarphp/ast/TypeRepr.h"
#include "polarphp/ast/Availability.h"
#include "polarphp/basic/InlineBitfield.h"
#include "polarphp/utils/TrailingObjects.h"
#include <utility>

namespace polar::ast {

enum class AccessKind : unsigned char;
class ArchetypeType;
class AstContext;
class AvailabilitySpec;
class Type;
class ValueDecl;
class Decl;
class DeclRefExpr;
class OpenedArchetypeType;
class SubscriptDecl;
class Stmt;
class BraceStmt;
class AstWalker;
class Initializer;
class VarDecl;
class OpaqueValueExpr;
class FuncDecl;
class ConstructorDecl;
class TypeDecl;
class PatternBindingDecl;
class ParameterList;
class EnumElementDecl;
class CallExpr;

using polar::basic::FunctionRef;

enum class ExprKind : uint8_t {
#define EXPR(Id, Parent) Id,
#define LAST_EXPR(Id) Last_Expr = Id,
#define EXPR_RANGE(Id, FirstId, LastId) \
   First_##Id##Expr = FirstId, Last_##Id##Expr = LastId,
#include "polarphp/ast/ExprNodesDefs.h"
};

enum : unsigned
{
   NumExprKindBits =
   polar::basic::count_bits_used(static_cast<unsigned>(ExprKind::Last_Expr))
};

/// Discriminates certain kinds of checked cast that have specialized diagnostic
/// and/or code generation peephole behavior.
///
/// This enumeration should not have any semantic effect on the behavior of a
/// well-typed program, since the runtime can perform all casts that are
/// statically accepted.
enum class CheckedCastKind : unsigned
{
   /// The kind has not been determined yet.
   Unresolved,

   /// Valid resolved kinds start here.
   First_Resolved,

   /// The requested cast is an implicit conversion, so this is a coercion.
   Coercion = First_Resolved,
   /// A checked cast with no known specific behavior.
   ValueCast,
   // A downcast from an array type to another array type.
   ArrayDowncast,
   // A downcast from a dictionary type to another dictionary type.
   DictionaryDowncast,
   // A downcast from a set type to another set type.
   SetDowncast,
   /// A bridging conversion that always succeeds.
   BridgingCoercion,

   Last_CheckedCastKind = BridgingCoercion,
};

/// What are the high-level semantics of this access?
enum class AccessSemantics : uint8_t
{
   /// On a storage reference, this is a direct access to the underlying
   /// physical storage, bypassing any observers.  The declaration must be
   /// a variable with storage.
   ///
   /// On a function reference, this is a non-polymorphic access to a
   /// particular implementation.
   DirectToStorage,

   /// On a storage reference, this is a direct access to the concrete
   /// implementation of this storage, bypassing any possibility of override.
   DirectToImplementation,

   /// This is an ordinary access to a declaration, using whatever
   /// polymorphism is expected.
   Ordinary,
};

/// Expr - Base class for all expressions in swift.
class alignas(8) Expr
{
   Expr(const Expr&) = delete;
   void operator=(const Expr&) = delete;

   protected:
   union {
      uint64_t OpaqueBits;
      POLAR_INLINE_BITFIELD_BASE(
               Expr, bitmax(NumExprKindBits,8)+1,
               /// The subclass of Expr that this is.
               kind : bitmax(NumExprKindBits,8),
               /// Whether the Expr represents something directly written in source or
               /// it was implicitly generated by the type-checker.
               implicit : 1
               );

      POLAR_INLINE_BITFIELD_FULL(
               CollectionExpr, Expr, 64-NumExprBits,
               /// True if the type of this collection expr was inferred by the collection
               /// fallback type, like [Any].
               IsTypeDefaulted : 1,
               /// Number of comma source locations.
               NumCommas : 32 - 1 - NumExprBits,
               /// Number of entries in the collection. If this is a DictionaryExpr,
               /// each entry is a Tuple with the key and value pair.
               NumSubExprs : 32
               );

      POLAR_INLINE_BITFIELD_EMPTY(LiteralExpr, Expr);
      POLAR_INLINE_BITFIELD_EMPTY(IdentityExpr, Expr);
      POLAR_INLINE_BITFIELD(
               LookupExpr, Expr, 1,
               IsSuper : 1
               );
      POLAR_INLINE_BITFIELD_EMPTY(
               DynamicLookupExpr, LookupExpr);

      POLAR_INLINE_BITFIELD(
               ParenExpr, IdentityExpr, 1,
               /// Whether we're wrapping a trailing closure expression.
               HasTrailingClosure : 1
               );

      POLAR_INLINE_BITFIELD(
               NumberLiteralExpr, LiteralExpr, 1,
               IsNegative : 1
               );

      POLAR_INLINE_BITFIELD(
               StringLiteralExpr, LiteralExpr, 3+1+1,
               Encoding : 3,
               IsSingleUnicodeScalar : 1,
               IsSingleExtendedGraphemeCluster : 1
               );

      POLAR_INLINE_BITFIELD_FULL(
               InterpolatedStringLiteralExpr, LiteralExpr, 32+20,
               : NumPadBits,
               InterpolationCount : 20,
               LiteralCapacity : 32
               );

      POLAR_INLINE_BITFIELD(
               DeclRefExpr, Expr, 2+2,
               Semantics : 2, // an AccessSemantics
               FunctionRefKind : 2
               );

      POLAR_INLINE_BITFIELD(
               UnresolvedDeclRefExpr, Expr, 2+2,
               DeclRefKind : 2,
               FunctionRefKind : 2
               );

      POLAR_INLINE_BITFIELD(
               MemberRefExpr, LookupExpr, 2,
               Semantics : 2 // an AccessSemantics
               );

      POLAR_INLINE_BITFIELD_FULL(
               TupleElementExpr, Expr, 32,
               : NumPadBits,
               FieldNo : 32
               );

      POLAR_INLINE_BITFIELD_FULL(
               TupleExpr, Expr, 1+1+1+32,
               /// Whether this tuple has a trailing closure.
               HasTrailingClosure : 1,

               /// Whether this tuple has any labels.
               HasElementNames : 1,

               /// Whether this tuple has label locations.
               HasElementNameLocations : 1,

               : NumPadBits,
               NumElements : 32
               );

      POLAR_INLINE_BITFIELD(
               UnresolvedDotExpr, Expr, 2,
               FunctionRefKind : 2
               );

      POLAR_INLINE_BITFIELD_FULL(
               SubscriptExpr, LookupExpr, 2+1+1+16,
               Semantics : 2, // an AccessSemantics
               /// Whether the SubscriptExpr also has source locations for the argument
               /// label.
               HasArgLabelLocs : 1,
               /// Whether the last argument is a trailing closure.
               HasTrailingClosure : 1,
               : NumPadBits,
               /// # of argument labels stored after the SubscriptExpr.
               NumArgLabels : 16
               );

      POLAR_INLINE_BITFIELD_FULL(
               DynamicSubscriptExpr, DynamicLookupExpr, 1+1+16,
               /// Whether the DynamicSubscriptExpr also has source locations for the
               /// argument label.
               HasArgLabelLocs : 1,
               /// Whether the last argument is a trailing closure.
               HasTrailingClosure : 1,
               : NumPadBits,
               /// # of argument labels stored after the DynamicSubscriptExpr.
               NumArgLabels : 16
               );

      POLAR_INLINE_BITFIELD_FULL(
               UnresolvedMemberExpr, Expr, 1+1+1+16,
               /// Whether the UnresolvedMemberExpr has arguments.
               HasArguments : 1,
               /// Whether the UnresolvedMemberExpr also has source locations for the
               /// argument label.
               HasArgLabelLocs : 1,
               /// Whether the last argument is a trailing closure.
               HasTrailingClosure : 1,
               : NumPadBits,
               /// # of argument labels stored after the UnresolvedMemberExpr.
               NumArgLabels : 16
               );

      POLAR_INLINE_BITFIELD(
               OverloadSetRefExpr, Expr, 2,
               FunctionRefKind : 2
               );

      POLAR_INLINE_BITFIELD(
               BooleanLiteralExpr, LiteralExpr, 1,
               Value : 1
               );

      POLAR_INLINE_BITFIELD(
               MagicIdentifierLiteralExpr, LiteralExpr, 3+1,
               kind : 3,
               StringEncoding : 1
               );

      POLAR_INLINE_BITFIELD_FULL(
               ObjectLiteralExpr, LiteralExpr, 3+1+1+16,
               LitKind : 3,
               /// Whether the ObjectLiteralExpr also has source locations for the argument
               /// label.
               HasArgLabelLocs : 1,
               /// Whether the last argument is a trailing closure.
               HasTrailingClosure : 1,
               : NumPadBits,
               /// # of argument labels stored after the ObjectLiteralExpr.
               NumArgLabels : 16
               );

      POLAR_INLINE_BITFIELD(
               AbstractClosureExpr, Expr, (16-NumExprBits)+16,
               : 16 - NumExprBits, // Align and leave room for subclasses
               Discriminator : 16
               );

      POLAR_INLINE_BITFIELD(
               ClosureExpr, AbstractClosureExpr, 1,
               /// True if closure parameters were synthesized from anonymous closure
               /// variables.
               HasAnonymousClosureVars : 1
               );

      POLAR_INLINE_BITFIELD_FULL(
               BindOptionalExpr, Expr, 16,
               : NumPadBits,
               Depth : 16
               );

      POLAR_INLINE_BITFIELD_EMPTY(ImplicitConversionExpr, Expr);

      POLAR_INLINE_BITFIELD_FULL(
               TupleShuffleExpr, ImplicitConversionExpr, 2+16+16+16,
               TypeImpact : 2,
               : NumPadBits,
               NumCallerDefaultArgs : 16,
               /// This contains an entry for each element in the Expr type.  Each element
               /// specifies which index from the SubExpr that the destination element gets.
               /// If the element value is DefaultInitialize, then the destination value
               /// gets the default initializer for that tuple element value.
               NumElementMappings : 16,
               /// The arguments that are packed into the variadic element.
               NumVariadicArgs : 16
               );

      POLAR_INLINE_BITFIELD(
               ForceValueExpr, Expr, 1,
               ForcedIUO : 1
               );

      POLAR_INLINE_BITFIELD(
               InOutToPointerExpr, ImplicitConversionExpr, 1,
               IsNonAccessing : 1
               );

      POLAR_INLINE_BITFIELD(
               ArrayToPointerExpr, ImplicitConversionExpr, 1,
               IsNonAccessing : 1
               );

      POLAR_INLINE_BITFIELD_FULL(
               ErasureExpr, ImplicitConversionExpr, 32,
               : NumPadBits,
               NumConformances : 32
               );

      POLAR_INLINE_BITFIELD_FULL(
               UnresolvedSpecializeExpr, Expr, 32,
               : NumPadBits,
               NumUnresolvedParams : 32
               );

      POLAR_INLINE_BITFIELD_FULL(
               CaptureListExpr, Expr, 32,
               : NumPadBits,
               NumCaptures : 32
               );

      POLAR_INLINE_BITFIELD(
               ApplyExpr, Expr, 1+1,
               ThrowsIsSet : 1,
               Throws : 1
               );

      POLAR_INLINE_BITFIELD_FULL(
               CallExpr, ApplyExpr, 1+1+16,
               /// Whether the CallExpr also has source locations for the argument label.
               HasArgLabelLocs : 1,
               /// Whether the last argument is a trailing closure.
               HasTrailingClosure : 1,
               : NumPadBits,
               /// # of argument labels stored after the CallExpr.
               NumArgLabels : 16
               );

      enum { NumCheckedCastKindBits = 4 };
      POLAR_INLINE_BITFIELD(
               CheckedCastExpr, Expr, NumCheckedCastKindBits,
               CastKind : NumCheckedCastKindBits
               );
      static_assert(unsigned(CheckedCastKind::Last_CheckedCastKind)
                    < (1 << NumCheckedCastKindBits),
                    "unable to fit a CheckedCastKind in the given number of bits");

      POLAR_INLINE_BITFIELD_EMPTY(
               CollectionUpcastConversionExpr, Expr);

      POLAR_INLINE_BITFIELD(
               ObjCSelectorExpr, Expr, 2,
               /// The selector kind.
               SelectorKind : 2
               );

      POLAR_INLINE_BITFIELD(
               KeyPathExpr, Expr, 1,
               /// Whether this is an ObjC stringified keypath.
               IsObjC : 1
               );

      POLAR_INLINE_BITFIELD_FULL(
               SequenceExpr, Expr, 32,
               : NumPadBits,
               NumElements : 32
               );

   } bits;

   private:
   /// m_type - This is the type of the expression.
   Type m_type;

   protected:
   Expr(ExprKind kind, bool implicit, Type type = Type())
      : m_type(type)
   {
      bits.OpaqueBits = 0;
      bits.Expr.kind = unsigned(kind);
      bits.Expr.implicit = implicit;
   }

   public:
   /// Return the kind of this expression.
   ExprKind getKind() const
   {
      return ExprKind(bits.Expr.kind);
   }

   /// Retrieve the name of the given expression kind.
   ///
   /// This name should only be used for debugging dumps and other
   /// developer aids, and should never be part of a diagnostic or exposed
   /// to the user of the compiler in any way.
   static StringRef getKindName(ExprKind kind);

   /// getType - Return the type of this expression.
   Type getType() const
   {
      return m_type;
   }

   /// setType - Sets the type of this expression.
   void setType(Type type);

   /// Return the source range of the expression.
   SourceRange getSourceRange() const;

   /// getStartLoc - Return the location of the start of the expression.
   SourceLoc getStartLoc() const;

   /// Retrieve the location of the last token of the expression.
   SourceLoc getEndLoc() const;

   /// getLoc - Return the caret location of this expression.
   SourceLoc getLoc() const;

#define POLAR_FORWARD_SOURCE_LOCS_TO(SUBEXPR) \
   SourceLoc getStartLoc() const { return (SUBEXPR)->getStartLoc(); } \
   SourceLoc getEndLoc() const { return (SUBEXPR)->getEndLoc(); } \
   SourceLoc getLoc() const { return (SUBEXPR)->getLoc(); } \
   SourceRange getSourceRange() const { return (SUBEXPR)->getSourceRange(); }

   SourceLoc trailingSemiLoc;

   /// getSemanticsProvidingExpr - Find the smallest subexpression
   /// which obeys the property that evaluating it is exactly
   /// equivalent to evaluating this expression.
   ///
   /// Looks through parentheses.  Would not look through something
   /// like '(foo(), x:bar(), baz()).x'.
   Expr *getSemanticsProvidingExpr();

   const Expr *getSemanticsProvidingExpr() const
   {
      return const_cast<Expr *>(this)->getSemanticsProvidingExpr();
   }

   /// getValueProvidingExpr - Find the smallest subexpression which is
   /// responsible for generating the value of this expression.
   /// Evaluating the result is not necessarily equivalent to
   /// evaluating this expression because of potential missing
   /// side-effects (which may influence the returned value).
   Expr *getValueProvidingExpr();

   const Expr *getValueProvidingExpr() const
   {
      return const_cast<Expr *>(this)->getValueProvidingExpr();
   }

   /// If this is a reference to an operator written as a member of a type (or
   /// extension thereof), return the underlying operator reference.
   DeclRefExpr *getMemberOperatorRef();

   /// This recursively walks the AST rooted at this expression.
   Expr *walk(AstWalker &walker);
   Expr *walk(AstWalker &&walker)
   {
      return walk(walker);
   }

   /// Enumerate each immediate child expression of this node, invoking the
   /// specific functor on it.  This ignores statements and other non-expression
   /// children.
   void forEachImmediateChildExpr(FunctionRef<Expr *(Expr *)> callback);

   /// Enumerate each expr node within this expression subtree, invoking the
   /// specific functor on it.  This ignores statements and other non-expression
   /// children, and if there is a closure within the expression, this does not
   /// walk into the body of it (unless it is single-expression).
   void forEachChildExpr(FunctionRef<Expr *(Expr *)> callback);

   /// Determine whether this expression refers to a type by name.
   ///
   /// This distinguishes static references to types, like Int, from metatype
   /// values, "someTy: Any.Type".
   bool isTypeReference(FunctionRef<Type(const Expr *)> getType =
         [](const Expr *E) -> Type { return E->getType(); },
                        FunctionRef<Decl *(const Expr *)> getDecl =
         [](const Expr *E) -> Decl * { return nullptr;}) const;

   /// Determine whether this expression refers to a statically-derived metatype.
   ///
   /// This implies `isTypeReference`, but also requires that the referenced type
   /// is not an archetype or dependent type.
   bool isStaticallyDerivedMetatype(
            FunctionRef<Type(const Expr *)> getType =
         [](const Expr *E) -> Type { return E->getType(); },
            FunctionRef<bool(const Expr *)> isTypeReference =
         [](const Expr *E) { return E->isTypeReference(); }) const;

   /// isImplicit - Determines whether this expression was implicitly-generated,
   /// rather than explicitly written in the AST.
   bool isImplicit() const
   {
      return bits.Expr.implicit;
   }

   void setImplicit(bool implicit = true)
   {
      bits.Expr.implicit = implicit;
   }

   /// Retrieves the declaration that is being referenced by this
   /// expression, if any.
//   ConcreteDeclRef getReferencedDecl() const;

   /// Determine whether this expression is 'super', possibly converted to
   /// a base class.
   bool isSuperExpr() const;

   /// Returns whether the semantically meaningful content of this expression is
   /// an inout expression.
   ///
   /// FIXME(Remove InOutType): This should eventually sub-in for
   /// 'E->getType()->is<InOutType>()' in all cases.
   bool isSemanticallyInOutExpr() const
   {
      return getSemanticsProvidingExpr()->getKind() == ExprKind::InOut;
   }

   /// Returns false if this expression needs to be wrapped in parens when
   /// used inside of a any postfix expression, true otherwise.
   ///
   /// \param appendingPostfixOperator if the expression being
   /// appended is a postfix operator like '!' or '?'.
   bool canAppendPostfixExpression(bool appendingPostfixOperator = false) const;

   /// Returns true if this is an infix operator of some sort, including
   /// a builtin operator.
   bool isInfixOperator() const;

   /// Returns true if this is a reference to the implicit self of function.
   bool isSelfExprOf(const AbstractFunctionDecl *AFD,
                     bool sameBase = false) const;

   /// Produce a mapping from each subexpression to its parent
   /// expression, with the provided expression serving as the root of
   /// the parent map.
   DenseMap<Expr *, Expr *> getParentMap();

   /// Produce a mapping from each subexpression to its depth and parent,
   /// in the root expression. The root expression has depth 0, its children have
   /// depth 1, etc.
   DenseMap<Expr *, std::pair<unsigned, Expr *>> getDepthMap();

   /// Produce a mapping from each expression to its index according to a
   /// preorder traversal of the expressions. The parent has index 0, its first
   /// child has index 1, its second child has index 2 if the first child is a
   /// leaf node, etc.
   DenseMap<Expr *, unsigned> getPreorderIndexMap();

   POLAR_ATTRIBUTE_DEPRECATED(
            void dump() const POLAR_ATTRIBUTE_USED,
            "only for use within the debugger");
   void dump(RawOutStream &outStream, unsigned indent = 0) const;
   void dump(RawOutStream &outStream, FunctionRef<Type(const Expr *)> getType,
             FunctionRef<Type(const TypeLoc &)> getTypeOfTypeLoc,
             unsigned indent = 0) const;

   void print(AstPrinter &printer, const PrintOptions &opts) const;

   // Only allow allocation of Exprs using the allocator in AstContext
   // or by doing a placement new.
   void *operator new(size_t bytes, AstContext &C,
                      unsigned alignment = alignof(Expr));

   // Make placement new and vanilla new/delete illegal for Exprs.
   void *operator new(size_t bytes) throw() = delete;
   void operator delete(void *data) throw() = delete;

   void *operator new(size_t bytes, void *mem)
   {
      assert(mem);
      return mem;
   }
};

/// Helper class to capture trailing call argument labels and related
/// information, for expression nodes that involve argument labels, trailing
/// closures, etc.
template<typename Derived>
class TrailingCallArguments
      : private polar::utils::TrailingObjects<Derived, Identifier, SourceLoc>
{
   // We need to friend class TrailingObjects twice here to work around an MSVC bug.
   // If we have two functions of the same name with the parameter
   // typename TrailingObjectsIdentifier::template OverloadToken<T> where T is
   // different for each function, then MSVC reports a "member function already
   // defined or declared" error, which is incorrect.
   using TrailingObjectsIdentifier = polar::utils::TrailingObjects<Derived, Identifier>;
   friend TrailingObjectsIdentifier;

   using TrailingObjects = polar::utils::TrailingObjects<Derived, Identifier, SourceLoc>;
   friend TrailingObjects;

   Derived &asDerived()
   {
      return *static_cast<Derived *>(this);
   }

   const Derived &asDerived() const
   {
      return *static_cast<const Derived *>(this);
   }

   size_t numTrailingObjects(
         typename TrailingObjectsIdentifier::template OverloadToken<Identifier>)
   const
   {
      return asDerived().getNumArguments();
   }

   size_t numTrailingObjects(
         typename TrailingObjectsIdentifier::template OverloadToken<SourceLoc>)
   const
   {
      return asDerived().hasArgumentLabelLocs() ? asDerived().getNumArguments()
                                                : 0;
   }

   /// Retrieve the buffer containing the argument labels.
   MutableArrayRef<Identifier> getArgumentLabelsBuffer()
   {
      return { this->template getTrailingObjects<Identifier>(),
         asDerived().getNumArguments() };
   }

   /// Retrieve the buffer containing the argument label locations.
   MutableArrayRef<SourceLoc> getArgumentLabelLocsBuffer()
   {
      if (!asDerived().hasArgumentLabelLocs())
         return { };

      return { this->template getTrailingObjects<SourceLoc>(),
         asDerived().getNumArguments() };
   }

protected:
   /// Determine the total size to allocate.
   static size_t totalSizeToAlloc(ArrayRef<Identifier> argLabels,
                                  ArrayRef<SourceLoc> argLabelLocs,
                                  bool hasTrailingClosure)
   {
      return TrailingObjects::template totalSizeToAlloc<Identifier, SourceLoc>(
               argLabels.size(), argLabelLocs.size());
   }

   /// Initialize the actual call arguments.
   void initializeCallArguments(ArrayRef<Identifier> argLabels,
                                ArrayRef<SourceLoc> argLabelLocs,
                                bool hasTrailingClosure)
   {
      if (!argLabels.empty()) {
         std::uninitialized_copy(argLabels.begin(), argLabels.end(),
                                 this->template getTrailingObjects<Identifier>());
      }

      if (!argLabelLocs.empty()) {
         std::uninitialized_copy(argLabelLocs.begin(), argLabelLocs.end(),
                                 this->template getTrailingObjects<SourceLoc>());
      }
   }

public:
   /// Retrieve the argument labels provided at the call site.
   ArrayRef<Identifier> getArgumentLabels() const
   {
      return { this->template getTrailingObjects<Identifier>(),
         asDerived().getNumArguments() };
   }

   /// Retrieve the buffer containing the argument label locations.
   ArrayRef<SourceLoc> getArgumentLabelLocs() const
   {
      if (!asDerived().hasArgumentLabelLocs())
         return { };

      return { this->template getTrailingObjects<SourceLoc>(),
         asDerived().getNumArguments() };
   }

   /// Retrieve the location of the ith argument label.
   SourceLoc getArgumentLabelLoc(unsigned i) const
   {
      auto locs = getArgumentLabelLocs();
      return i < locs.size() ? locs[i] : SourceLoc();
   }
};

/// ErrorExpr - Represents a semantically erroneous subexpression in the AST,
/// typically this will have an ErrorType.
class ErrorExpr : public Expr
{
   SourceRange m_range;
public:
   ErrorExpr(SourceRange range, Type type = Type())
      : Expr(ExprKind::Error, /*implicit=*/true, type),
        m_range(range)
   {}

   SourceRange getSourceRange() const
   {
      return m_range;
   }

   static bool classof(const Expr *expr)
   {
      return expr->getKind() == ExprKind::Error;
   }
};

} // polar::ast

#endif // POLARPHP_AST_EXPR_H
